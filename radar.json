[
  {
    "name": "Domain Driven Design",
    "quadrant": "Techniques",
    "ring": "Adopt",
    "description": "<p><a href=\"https://martinfowler.com/bliki/DomainDrivenDesign.html\">Domain Driven Design</a> is a philosophy that was popularized by Eric Evans that asserts that the best software designs are produced when the developers learn about the business domain and construct a model that is informed by that understanding and then implement that model as literally as possible in their code. Domain Driven Design requires systems to be able to isolate domain code, or business logic, from other concerns like network requests or database queries.</p>\n<p>Systems built using Domain Driven Design will be easier to maintain, be less buggy, and be easier to modify with new capabilities. To learn more check out the <a href=\"https://github.com/synapsestudios/coding-workshop\">Domain Modeling Workshop</a> repo where you'll find some pattern documentation and modeling exercises.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "NestJS",
    "quadrant": "Languages and Frameworks",
    "ring": "Adopt",
    "description": "<p>Most of the work Synapse does can most responsibly be done with the <a href=\"https://www.youtube.com/watch?v=5OjqD-ow8GE\">modular monolith</a> architecture pattern, and we have been using <a href=\"https://nestjs.com/\">NestJS</a> to build these monoliths. Nest is a fairly heavy weight framework, which makes it an unusual choice for Synapse, but it has a very good module system, it's very popular, and it's well designed.</p>\n<p>Because it has a bigger footprint than the frameworks we've historically used it will be important to strictly define the boundaries between the parts of our code that are allowed to know about the framework, and the parts that aren't.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Tanstack Query (aka react-query)",
    "quadrant": "Tools",
    "ring": "Adopt",
    "description": "<p><a href=\"https://tanstack.com/query/v3/docs/react/overview\">Tanstack-Query</a> is a library for caching the results of promises in a React frontend. It is mainly used for caching the results of fetch requests to the api, to mitigate duplicate requests, and to invalidate caches, simplifying the refetching that must occur after mutations to the api data occur. Historically, Synapse used <a href=\"https://redux.js.org/\">Redux</a> for a long time to manage sever cache on the client. Though most of the React community has moved on from raw Redux for managing this, tools like Redux Toolkit still exist for simplifying this usage of Redux.</p>\n<p>Tanstack-Query is ergonomic to use as both a hook within a component, or as a function call if the fetch occurs within a promise chain. It encourages separation between queries and mutations (commands), which follows CQRS. It provides useful features for mocking the cache state for the purpose of testing, as well as disabling some of the cache features in order to make tests more deterministic. The community support for this library is very good, and it is well documented.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Title3",
    "quadrant": "Tools",
    "ring": "Adopt",
    "description": "<p>Description</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Detox",
    "quadrant": "Tools",
    "ring": "Trial",
    "description": "<p><a href=\"https://github.com/wix/Detox\">Detox</a> is a gray box end-to-end testing and automation library for react-native apps. It has only been integrated with brownfield apps, so the experience may differ greatly to the experience of integrating with a greenfield project. Experience tells us that getting the Detox suite to run in a CI, like GitHub Actions, can be very challenging for both iOS and Android. Detox seems to suffer from flakey handshakes between the Detox testing server and the simulator/emulator running the app under test. This flakiness can be hard to reproduce locally, so troubleshooting can be slow while waiting for CI cycle times.</p>\n<p>It should also be noted that Detox requires running on a macos environment, and will require using the macos runner for GitHub Actions, which is 10X more expensive than the linux runner. This limitation affects any e2e testing for the iOS app. Android testing with Detox also requires a macos environment, so there are no savings to be had there.</p>\n<p>Detox provides all the UI selectors one comes to expect for these kinds of tools. Some timeouts have been known to occur if there are complex animations or transitions in the app, or requests hanging indefinitely. Detox tries to solve flakiness by monitoring that &quot;idle&quot; state of the app, monitoring things like requests that are still inflight, or animations that are still running. Given the aforementioned timeouts, it is not clear whether it fully delivers on this promise of reducing flakiness.</p>\n<p>It is possible Detox is a better fit for greenfield projects that don't have to contend with older versions of navigation libraries, or deprecated launch screen libraries, which have been known to cause issues. There are still open issues with Detox for flakiness that is only reproduceable in CI, and it is not clear whether the Detox team is actively working on these issues.</p>\n<p>If Detox were chosen, it would be best to first implement a basic test that verifies that it can launch the app and assert about the default UI it sees. Then immediately after this, attempt to get the test running and passing in CI. The longer the time between these two steps, the more likely it is that there will be hidden failures that only occur in CI, where resources are constrained, and simulators/emulators are freshly installed between runs.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Next.js",
    "quadrant": "Languages and Frameworks",
    "ring": "Trial",
    "description": "<p><a href=\"https://nextjs.org/\">Next.js</a> is a popular React framework that offers a handful of nice features. For extremely dynamic sites and content Next.js offers a simplified framework for delivering React apps with server side rendering (SSR). SSR is becoming more popular as a default for single page applications because of the performance and SEO improvements. Some teams are even leveraging their SSR apps to open up api and data fetching design options. For example, you can access a database from your Next.js code and eliminate the need for backend frameworks.</p>\n<p>SSR frameworks are becoming ubiquitous. Fewer people are familiar with <a href=\"https://reactjs.org/docs/create-a-new-react-app.html#create-react-app\">create react app</a> and the technology involved in bundling a SPA for client side delivery and rendering. This is one of the biggest reasons to start trialing other frameworks, build tools, architectures and delivery methods.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Title1",
    "quadrant": "Techniques",
    "ring": "Trial",
    "description": "<p>Description</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "XState",
    "quadrant": "Tools",
    "ring": "Trial",
    "description": "<p><a href=\"https://xstate.js.org/docs/\">XState</a> is an in-memory state management solution that organizes state as finite state machines. It is dependency-free and can be used in any JavaScript environment, including the browser, Node.js, and React Native. It is also compatible with TypeScript.</p>\n<p>XState offers tools to integrate with React, allowing components to interact with xstate machines <a href=\"https://xstate.js.org/docs/packages/xstate-react/#quick-start\">via hooks</a>. XState also provides a <a href=\"https://stately.ai/viz\">visualizer</a> that can generate a statechart diagram from a machine definition, which can be useful for debugging and documentation. There is also a VSCode extension that can similarly be used to visualize the statecharts generated by a machine definition.</p>\n<p>XState is a good fit in areas where the state of an application is complex, or expected to become complex. Some examples for how it's been use in the past include:</p>\n<ol>\n<li>Managing the authentication state of the application, including the flow for logging in and logging out.</li>\n<li>Managing the bootstrap phase of a react-native application. This included the rehydration of state from cold storage, setting up geolocation services, push notification listener services, in-app permission state, among other things.</li>\n<li>Complex dynamic forms whose options change depending on prior selections.</li>\n<li>Complex wizards or workflows that must maintain state across multiple screens.</li>\n<li>Sequential flows that must be completed in a specific order, such as a welcome screen after login, then showing a tutorial, then prompting for a permission, etc.</li>\n<li>Interruptable async operations</li>\n</ol>\n<p>XState has a polarizing api, choosing to represent machines as long JSON objects. It also can have a steep learning curve. On top of learning fsm concepts, you must also learn the xstate api, which includes concepts like &quot;context&quot;, &quot;transitions&quot;, &quot;guards&quot;, &quot;actions&quot;, and &quot;services&quot;. There is nothing to prevent you from writing overly-nested, poorly organized state machines, so it is important to stay mindful of when a machine has too many responsibilities. And while XState does work with Typescript, it uses a <a href=\"https://xstate.js.org/docs/guides/typescript.html\">Typegen tool</a> to acheive this, which has drawbacks. It will require changes to your CI pipeline TS checks, in order to generate the type definitions before running the TS checks. It also requires that you run the typegen tool every time you make a change to your machine definition. There is cli and VSCode tooling for this, but it is additional setup.</p>\n<p>Testing XState machines is straightforward. It provides ways to mock out services, actions, or guards. It also supports <a href=\"https://xstate.js.org/docs/packages/xstate-test/\">model-based testing</a> to test a machine in every possible state. It's important to stay mindful you aren't testing the implementation details of a state machine by simply asserting about the machine's state, this seems to be a common trap people fall into.</p>\n<p>XState might not be a good fit for one-off areas of complexity. It is a costly tradeoff in terms of new developer onboarding. Reaching for a simpler solution, such as React's own <code>useReducer</code> may suffice in these situations. If the state of something is simple enough, like most CRUD UIs tend to be, XState may be overkill. XState incurs a cost in boilerplate for setup with React components, so simple UIs don't stand to benefit at all, except if the UI is expected to become more complex in the near future.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Bookshelf.js",
    "quadrant": "Tools",
    "ring": "Hold",
    "description": "<p>Synapse used <a href=\"https://bookshelfjs.org/\">Bookshelf.js</a> for the better part of a decade, beginning with our earliest projects after changing our preferred backend environment from PHP to Node.js. The things that we liked about it were that it used the <a href=\"https://knexjs.org/\">knex</a> query builder, which was well known for its ease-of-use and multi-database support, and that it was a lightweight ORM that reduced the amount of boilerplate code we'd need for CRUD operations.</p>\n<p>However, we have moved the bookshelf blip into our &quot;Hold&quot; ring for a few reasons. As our approach to building web applications has evolved, we have adopted a Domain Driven Design (DDD) architecture with a repository pattern, emphasizing the separation of concerns between the domain model and the persistence layer. Bookshelf.js primarily uses the active record pattern and is tightly coupled with the database schema, which makes it incompatible with our approach without a lot of extra code wrapping it. Another reason is we found that even with all the methods provided by bookshelf, we were writing a lot of custom code to handle the many-to-many relationships that are common in our applications, and the ORM lacked some things we commonly needed, like an official way to handle pagination (though community-created plugins were helpful). Finally, the bookshelf repository has fallen out of active development, and the community has moved on to other ORMs like <a href=\"https://vincit.github.io/objection.js/\">Objection.js</a>.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "hapi",
    "quadrant": "Languages and Frameworks",
    "ring": "Hold",
    "description": "<p>Synapse has used <a href=\"https://hapi.dev/\">hapi</a> for close to a decade. We originally adopted hapi for its strong culture, lightweight api, and security features. One important aspect of hapi has always been that it has no external dependencies at all. Hapi is and has always been completely isolated from <a href=\"https://circleci.com/blog/secure-software-supply-chain/?utm_source=google&amp;utm_medium=sem&amp;utm_campaign=sem-google-dg--uscan-en-dsa-tROAS-auth-nb&amp;utm_term=g_-_c__dsa_&amp;utm_content=&amp;gclid=CjwKCAjw_MqgBhAGEiwAnYOAemTlrPWDKv0v_kNRMIPVVLv6SDF925rd87LlZA6FXutlSeTpajtu-RoCca0QAvD_BwE\">supply chain</a> security issues.</p>\n<p>However, we have moved the hapi blip into our &quot;Hold&quot; ring for two reasons. One is that as of a couple of years ago we've rapidly adopted typescript. Working with hapi in typescript has been painful and we started to prefer typescript native frameworks. Our architectural preferences have also grown somewhat in that timeframe and we have grown to prefer a stronger modularization paradigm than hapi's plugins. We have especially fallen out of love with the convention in the hapi community to mutate the server object in order to pass around plugins and other dependencies. Hapi will probably always have a place at Synapse, but we are no longer starting new work with this framework.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Title2",
    "quadrant": "Platforms",
    "ring": "Hold",
    "description": "<p>Description</p>\n",
    "isNew": "TRUE"
  }
]