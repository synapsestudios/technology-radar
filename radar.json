[
  {
    "name": "Auth0 IDP",
    "quadrant": "Platforms",
    "ring": "Adopt",
    "description": "<p>Auth0 is a managed identity platform that serves as an alternative to the Synapse OIDC Provider as well as AWS Cognito and other similar services. Auth0 has a generous free plan and relatively low pricing for applications that don't have hundreds of thousands of monthly active users. It also has a React Native SDK that makes it straightforward to integrate into our React Native apps, and a well-documented administrative API.</p>\n<p>We have used Auth0 on a number of projects in production and have found it to be a good fit for our use cases. It has a number of benefits over other tools like Cognito:</p>\n<ul>\n<li>Ability to migrate users with password hashes from other OIDC providers or from other Auth0 tenants.</li>\n<li>Ability to invite users with a &quot;Set Password&quot; link, which is a common use case for us.</li>\n<li>Ability to customize the default screens and emails for login, signup, and password reset workflows.</li>\n<li>Very good React Native library with hooks support.</li>\n<li>Very good admin UI that makes it easy for non-developers to do administrative tasks.</li>\n<li>Very good documentation and support.</li>\n<li>Social SSO support for providers like Google, Apple, and Facebook</li>\n<li>HIPAA compliance</li>\n<li>MFA</li>\n<li>Passwordless login</li>\n</ul>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Chakra UI",
    "quadrant": "Tools",
    "ring": "Adopt",
    "description": "<p><a href=\"https://chakra-ui.com/\">Chakra UI</a> is a React component library which emphasizes accessibility, customization through theming, and simple component APIs. It gives a lot of nice features out of the box which can save a lot of development time, such as aria attributes, built-in focus management, a dark mode theme, and a responsive layout system. It also has excellent support for TypeScript.</p>\n<p>When getting started adding Chakra UI to an app, you should expect to spend a bit of time up-front configuring your app's theme, but once that's set up, you can use the components in your app with very little additional styling. We've found this to be a big win for productivity, in many cases eliminating the need for an extra design pass. It also makes it easier to maintain a consistent look and feel across the app.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Domain Driven Design",
    "quadrant": "Techniques",
    "ring": "Adopt",
    "description": "<p><a href=\"https://martinfowler.com/bliki/DomainDrivenDesign.html\">Domain Driven Design</a> is a philosophy that was popularized by Eric Evans that asserts that the best software designs are produced when the developers learn about the business domain and construct a model that is informed by that understanding and then implement that model as literally as possible in their code. Domain Driven Design requires systems to be able to isolate domain code, or business logic, from other concerns like network requests or database queries.</p>\n<p>Systems built using Domain Driven Design will be easier to maintain, be less buggy, and be easier to modify with new capabilities. To learn more check out the <a href=\"https://github.com/synapsestudios/coding-workshop\">Domain Modeling Workshop</a> repo where you'll find some pattern documentation and modeling exercises.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "NestJS",
    "quadrant": "Languages and Frameworks",
    "ring": "Adopt",
    "description": "<p>Most of the work Synapse does can most responsibly be done with the <a href=\"https://www.youtube.com/watch?v=5OjqD-ow8GE\">modular monolith</a> architecture pattern, and we have been using <a href=\"https://nestjs.com/\">NestJS</a> to build these monoliths. Nest is a fairly heavy weight framework, which makes it an unusual choice for Synapse, but it has a very good module system, it's very popular, and it's well designed.</p>\n<p>Because it has a bigger footprint than the frameworks we've historically used it will be important to strictly define the boundaries between the parts of our code that are allowed to know about the framework, and the parts that aren't.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "React Native Bootsplash",
    "quadrant": "Tools",
    "ring": "Adopt",
    "description": "<p><a href=\"https://github.com/zoontek/react-native-bootsplash\">React Native Bootsplash</a> is used for displaying a splash screen immediately after launching a React Native app, but before the component tree has finished mounting, and the app is not yet ready to display a screen from the navigation. The library it replaces, <a href=\"https://github.com/crazycodeboy/react-native-splash-screen\">React Native Splash Screen</a> is no longer actively maintained.</p>\n<p>React Native Bootsplash is implemented in a way that is compatible with the new <a href=\"https://developer.android.com/about/versions/12/features/splash-screen\">Splash Screen API</a> in Android 12. The <code>react-native-splash-screen</code> implementation tries to use a fullscreen modal dialog, which is not recommended by Google.</p>\n<p>It should also be noted that <code>react-native-splash-screen</code> has known issues with other tools, such as Detox for e2e testing, and the recommended solution is to use <code>react-native-bootsplash</code> instead.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Tanstack Query (aka react-query)",
    "quadrant": "Tools",
    "ring": "Adopt",
    "description": "<p><a href=\"https://tanstack.com/query/v3/docs/react/overview\">Tanstack-Query</a> is a library for caching the results of promises in a React frontend. It is mainly used for caching the results of fetch requests to the api, to mitigate duplicate requests, and to invalidate caches, simplifying the refetching that must occur after mutations to the api data occur. Historically, Synapse used <a href=\"https://redux.js.org/\">Redux</a> for a long time to manage sever cache on the client. Though most of the React community has moved on from raw Redux for managing this, tools like Redux Toolkit still exist for simplifying this usage of Redux.</p>\n<p>Tanstack-Query is ergonomic to use as both a hook within a component, or as a function call if the fetch occurs within a promise chain. It encourages separation between queries and mutations (commands), which follows CQRS. It provides useful features for mocking the cache state for the purpose of testing, as well as disabling some of the cache features in order to make tests more deterministic. The community support for this library is very good, and it is well documented.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Detox",
    "quadrant": "Tools",
    "ring": "Trial",
    "description": "<p><a href=\"https://github.com/wix/Detox\">Detox</a> is a gray box end-to-end testing and automation library for react-native apps. It has only been integrated with brownfield apps, so the experience may differ greatly to the experience of integrating with a greenfield project. Experience tells us that getting the Detox suite to run in a CI, like GitHub Actions, can be very challenging for both iOS and Android. Detox seems to suffer from flakey handshakes between the Detox testing server and the simulator/emulator running the app under test. This flakiness can be hard to reproduce locally, so troubleshooting can be slow while waiting for CI cycle times.</p>\n<p>It should also be noted that Detox requires running on a macos environment, and will require using the macos runner for GitHub Actions, which is 10X more expensive than the linux runner. This limitation affects any e2e testing for the iOS app. Android testing with Detox also requires a macos environment, so there are no savings to be had there.</p>\n<p>Detox provides all the UI selectors one comes to expect for these kinds of tools. Some timeouts have been known to occur if there are complex animations or transitions in the app, or requests hanging indefinitely. Detox tries to solve flakiness by monitoring that &quot;idle&quot; state of the app, monitoring things like requests that are still inflight, or animations that are still running. Given the aforementioned timeouts, it is not clear whether it fully delivers on this promise of reducing flakiness.</p>\n<p>It is possible Detox is a better fit for greenfield projects that don't have to contend with older versions of navigation libraries, or deprecated launch screen libraries, which have been known to cause issues. There are still open issues with Detox for flakiness that is only reproduceable in CI, and it is not clear whether the Detox team is actively working on these issues.</p>\n<p>If Detox were chosen, it would be best to first implement a basic test that verifies that it can launch the app and assert about the default UI it sees. Then immediately after this, attempt to get the test running and passing in CI. The longer the time between these two steps, the more likely it is that there will be hidden failures that only occur in CI, where resources are constrained, and simulators/emulators are freshly installed between runs.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Next.js",
    "quadrant": "Languages and Frameworks",
    "ring": "Trial",
    "description": "<p><a href=\"https://nextjs.org/\">Next.js</a> is a popular React framework that offers a handful of nice features. For extremely dynamic sites and content Next.js offers a simplified framework for delivering React apps with server side rendering (SSR). SSR is becoming more popular as a default for single page applications because of the performance and SEO improvements. Some teams are even leveraging their SSR apps to open up api and data fetching design options. For example, you can access a database from your Next.js code and eliminate the need for backend frameworks.</p>\n<p>SSR frameworks are becoming ubiquitous. Fewer people are familiar with <a href=\"https://reactjs.org/docs/create-a-new-react-app.html#create-react-app\">create react app</a> and the technology involved in bundling a SPA for client side delivery and rendering. This is one of the biggest reasons to start trialing other frameworks, build tools, architectures and delivery methods.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Prisma",
    "quadrant": "Tools",
    "ring": "Trial",
    "description": "<p>Prisma is a Node.js library that provides a type-safe database access layer with a modern API. Prisma supports multiple databases such as PostgreSQL, MySQL, and SQLite, and it provides a database schema designer tool that generates a type-safe client library from the schema.</p>\n<p>Prisma's main advantages are:</p>\n<ul>\n<li>Type-safety: Prisma's client library is generated from the database schema, so it provides type-safety and auto-completion for queries automatically. This helps to catch errors early and provides better IDE support, and doesn't run the risk of manually-generated result types not matching the database schema.</li>\n<li>Performance: Prisma provides query profiling and optimization tools to help optimize the database queries.</li>\n<li>Migration tool: Prisma provides a migration tool that helps manage database schema changes in a version-controlled way. The migration tool generates migration files that can be reviewed and applied manually or automatically.</li>\n<li>Community: Prisma has a large and active community with many examples, plugins, and integrations with other popular tools and frameworks such as Apollo GraphQL, Next.js, and Nest.js.</li>\n</ul>\n<p>There are some potential drawbacks to using Prisma, including:</p>\n<ul>\n<li>Learning curve: Prisma has its own syntax and concepts that may take some time to learn and adapt to. For example, Prisma's query builder syntax is different from SQL or other ORMs, and it has its own data modeling language.</li>\n<li>Limited control: Prisma's API is optimized for typical use cases, but it may not cover all edge cases or advanced features of the database. In some cases, developers may need to use raw SQL which is a little bit kludgy in Prisma.</li>\n<li>Difficult to debug: When things <em>do</em> go wrong with Prisma, especially with the schema or migration tools, it can be difficult to tell where the problem lies since the error messages and stack traces aren't always helpful.</li>\n</ul>\n<p>We're trialing this primarily because the developer experience is so good in terms of TypeScript usage and community support. It should still be used responsibly and isolated to the infrastructure layers of the codebase by using patterns such as the Repository pattern.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Slonik",
    "quadrant": "Tools",
    "ring": "Trial",
    "description": "<p>Slonik is a Node.js Postgres client with TypeScript support which promotes writing raw SQL. It generates SQL-injection-safe queries using ES6 template tags and has various convenience methods and hooks into features (e.g. type parsers, which lets us override how Postgres types are converted to JavaScript and vice-versa).</p>\n<p>Using raw SQL has several benefits when used responsibly with good architectural practices, such as the Repository pattern. It makes it easy to track down problematic queries in the code when using tools such as the slow query log. It also allows engineers to easily prototype queries in a SQL client and then implement them by pasting a query into the codebase, or to debug problematic queries in the codebase by pasting them into a SQL client. This means engineers don't have to remember how to convert a query between SQL and their query builder library's interfaces.</p>\n<p>It also helps ensure (when paired with linter rules and code review practices) that no database access happens outside of repositories, and generally promotes good SQL knowledge among the team. It gives engineers more flexibility in the queries that are used, so they can be optimized for performance or to use special features or data structures of the database that aren't always exposed by query builders or ORMs.</p>\n<p>The downsides to using Slonik include:</p>\n<ul>\n<li>Community: the community support (Q&amp;As, examples, companion tools/plugins) is very small compared to popular ORMs and query builders.</li>\n<li>Stability: they have introduced major breaking changes/redesigns to their public interface repeatedly in the last several years. This has contributed to the stagnation of the community mentioned above.</li>\n<li>Lack of migration tool: there was a third party tool called <code>slonik-migrator</code> to facilitate migrations using Slonik, but unfortunately it has not been updated to support the last several major Slonik versions and now needs a major refactor.</li>\n<li>Types: Slonik isn't aware of the database schema in the same way as ORMs like Prisma, so you have to create your own Result types, which may allow bugs to slip through if your types don't match the schema.</li>\n</ul>\n<p>Overall, if Slonik can stabilize their API and improve their community support, it will likely be an easy win for us.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Title1",
    "quadrant": "Techniques",
    "ring": "Trial",
    "description": "<p>Description</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Title5",
    "quadrant": "languages-and-frameworks",
    "ring": "Trial",
    "description": "<p>Description goes here</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "XState",
    "quadrant": "Tools",
    "ring": "Trial",
    "description": "<p><a href=\"https://xstate.js.org/docs/\">XState</a> is an in-memory state management solution that organizes state as finite state machines. It is dependency-free and can be used in any JavaScript environment, including the browser, Node.js, and React Native. It is also compatible with TypeScript.</p>\n<p>XState offers tools to integrate with React, allowing components to interact with xstate machines <a href=\"https://xstate.js.org/docs/packages/xstate-react/#quick-start\">via hooks</a>. XState also provides a <a href=\"https://stately.ai/viz\">visualizer</a> that can generate a statechart diagram from a machine definition, which can be useful for debugging and documentation. There is also a VSCode extension that can similarly be used to visualize the statecharts generated by a machine definition.</p>\n<p>XState is a good fit in areas where the state of an application is complex, or expected to become complex. Some examples for how it's been use in the past include:</p>\n<ol>\n<li>Managing the authentication state of the application, including the flow for logging in and logging out.</li>\n<li>Managing the bootstrap phase of a react-native application. This included the rehydration of state from cold storage, setting up geolocation services, push notification listener services, in-app permission state, among other things.</li>\n<li>Complex dynamic forms whose options change depending on prior selections.</li>\n<li>Complex wizards or workflows that must maintain state across multiple screens.</li>\n<li>Sequential flows that must be completed in a specific order, such as a welcome screen after login, then showing a tutorial, then prompting for a permission, etc.</li>\n<li>Interruptable async operations</li>\n</ol>\n<p>XState has a polarizing api, choosing to represent machines as long JSON objects. It also can have a steep learning curve. On top of learning fsm concepts, you must also learn the xstate api, which includes concepts like &quot;context&quot;, &quot;transitions&quot;, &quot;guards&quot;, &quot;actions&quot;, and &quot;services&quot;. There is nothing to prevent you from writing overly-nested, poorly organized state machines, so it is important to stay mindful of when a machine has too many responsibilities. And while XState does work with Typescript, it uses a <a href=\"https://xstate.js.org/docs/guides/typescript.html\">Typegen tool</a> to acheive this, which has drawbacks. It will require changes to your CI pipeline TS checks, in order to generate the type definitions before running the TS checks. It also requires that you run the typegen tool every time you make a change to your machine definition. There is cli and VSCode tooling for this, but it is additional setup.</p>\n<p>Testing XState machines is straightforward. It provides ways to mock out services, actions, or guards. It also supports <a href=\"https://xstate.js.org/docs/packages/xstate-test/\">model-based testing</a> to test a machine in every possible state. It's important to stay mindful you aren't testing the implementation details of a state machine by simply asserting about the machine's state, this seems to be a common trap people fall into.</p>\n<p>XState might not be a good fit for one-off areas of complexity. It is a costly tradeoff in terms of new developer onboarding. Reaching for a simpler solution, such as React's own <code>useReducer</code> may suffice in these situations. If the state of something is simple enough, like most CRUD UIs tend to be, XState may be overkill. XState incurs a cost in boilerplate for setup with React components, so simple UIs don't stand to benefit at all, except if the UI is expected to become more complex in the near future.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Bookshelf.js",
    "quadrant": "Tools",
    "ring": "Hold",
    "description": "<p>Synapse used <a href=\"https://bookshelfjs.org/\">Bookshelf.js</a> for the better part of a decade, beginning with our earliest projects after changing our preferred backend environment from PHP to Node.js. The things that we liked about it were that it used the <a href=\"https://knexjs.org/\">knex</a> query builder, which was well known for its ease-of-use and multi-database support, and that it was a lightweight ORM that reduced the amount of boilerplate code we'd need for CRUD operations.</p>\n<p>However, we have moved the bookshelf blip into our &quot;Hold&quot; ring for a few reasons. As our approach to building web applications has evolved, we have adopted a Domain Driven Design (DDD) architecture with a repository pattern, emphasizing the separation of concerns between the domain model and the persistence layer. Bookshelf.js primarily uses the active record pattern and is tightly coupled with the database schema, which makes it incompatible with our approach without a lot of extra code wrapping it. Another reason is we found that even with all the methods provided by bookshelf, we were writing a lot of custom code to handle the many-to-many relationships that are common in our applications, and the ORM lacked some things we commonly needed, like an official way to handle pagination (though community-created plugins were helpful). Finally, the bookshelf repository has fallen out of active development, and the community has moved on to other ORMs like <a href=\"https://vincit.github.io/objection.js/\">Objection.js</a>.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "AWS Cognito OIDC IDP",
    "quadrant": "Platforms",
    "ring": "Hold",
    "description": "<p>Cognito is a managed identity platform by AWS that supports OIDC authentication workflows, as well as many other use cases. This blip is specifically about Cognito as an OIDC IDP, and not other use cases, such as granting users access to AWS resources from our frontends (e.g. to upload files directly to S3 without streaming through our backend).</p>\n<p>The primary benefit of Cognito is that it's available by default to us in AWS, which means our clients typically will not need to register and pay for a separate identity provider. It's fully-managed, so we don't have to worry about configuring infrastructure or patching security issues. It also has a React Native SDK via AWS Amplify, which makes it straightforward to integrate into our React Native apps, and a well-documented administrative API.</p>\n<p>However, after using it on a project in production, we found a number of drawbacks that make other alternatives like Auth0 more attractive:</p>\n<ul>\n<li>The admin API doesn't have the same level of functionality as our Synapse OIDC Provider or Auth0. For example, there's no way to invite a user with an email containing a &quot;Set Password&quot; link, which is a common use case for us. By default, it sends an email to the user with a plaintext password. There's not even a way to generate a &quot;set password&quot; token programatically and send it to the user via our own email service. Additionally, these passwords expire, and once they do, there's no way to reset them without invoking the admin API from our backend.</li>\n<li>The admin UI is not very user-friendly and is buried in the AWS console, which makes it more difficult for non-developers to do any administrative tasks.</li>\n<li>There is no way to migrate users to a Cognito user pool with passwords already set. This means that if we want to migrate users from another OIDC provider or from another Cognito user pool, we have to ask them to reset their passwords or orchestrate a complex transparent migration.</li>\n<li>Some user pool changes require creating a new user pool and migrating users to it. For example, user pools default to using case-sensitive emails, which is undesirable for our use cases especially when using an invitation workflow (the person inviting the user may not type their email with the same capitalization that the user does). Changing this requires creating a new user pool and migrating users to it.</li>\n<li>The React Native SDK is not very flexible. The customization options for the default screens are very limited, so we ended up using <code>aws-amplify</code> and <code>amazon-cognito-identity-js</code> packages to orchestrate the IDP workflows in our mobile app with our own custom React components. This took a significant amount of development effort and adds complexity to the codebase.</li>\n</ul>\n<p>Overall, the developer effort required to get Cognito to parity with other tools like Auth0 for our use cases just isn't going to be worth it. We will continue to use Cognito for other use cases, such as granting users access to AWS resources from our frontends, but we will not use it as an OIDC IDP.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "hapi",
    "quadrant": "Languages and Frameworks",
    "ring": "Hold",
    "description": "<p>Synapse has used <a href=\"https://hapi.dev/\">hapi</a> for close to a decade. We originally adopted hapi for its strong culture, lightweight api, and security features. One important aspect of hapi has always been that it has no external dependencies at all. Hapi is and has always been completely isolated from <a href=\"https://circleci.com/blog/secure-software-supply-chain/?utm_source=google&amp;utm_medium=sem&amp;utm_campaign=sem-google-dg--uscan-en-dsa-tROAS-auth-nb&amp;utm_term=g_-_c__dsa_&amp;utm_content=&amp;gclid=CjwKCAjw_MqgBhAGEiwAnYOAemTlrPWDKv0v_kNRMIPVVLv6SDF925rd87LlZA6FXutlSeTpajtu-RoCca0QAvD_BwE\">supply chain</a> security issues.</p>\n<p>However, we have moved the hapi blip into our &quot;Hold&quot; ring for two reasons. One is that as of a couple of years ago we've rapidly adopted typescript. Working with hapi in typescript has been painful and we started to prefer typescript native frameworks. Our architectural preferences have also grown somewhat in that timeframe and we have grown to prefer a stronger modularization paradigm than hapi's plugins. We have especially fallen out of love with the convention in the hapi community to mutate the server object in order to pass around plugins and other dependencies. Hapi will probably always have a place at Synapse, but we are no longer starting new work with this framework.</p>\n",
    "isNew": "TRUE"
  },
  {
    "name": "Title2",
    "quadrant": "Platforms",
    "ring": "Hold",
    "description": "<p>Description</p>\n",
    "isNew": "TRUE"
  }
]