---
quadrant: Tools
isNew: true
ring: Trial
name: XState
---

[XState](https://xstate.js.org/docs/) is an in-memory state management solution that organizes state as finite state machines. It is dependency-free and can be used in any JavaScript environment, including the browser, Node.js, and React Native. It is also compatible with TypeScript.

XState offers tools to integrate with React, allowing components to interact with xstate machines [via hooks](https://xstate.js.org/docs/packages/xstate-react/#quick-start). XState also provides a [visualizer](https://stately.ai/viz) that can generate a statechart diagram from a machine definition, which can be useful for debugging and documentation. There is also a VSCode extension that can similarly be used to visualize the statecharts generated by a machine definition.

XState is a good fit in areas where the state of an application is complex, or expected to become complex. Some examples for how it's been use in the past include:
1. Managing the authentication state of the application, including the flow for logging in and logging out.
2. Managing the bootstrap phase of a react-native application. This included the rehydration of state from cold storage, setting up geolocation services, push notification listener services, in-app permission state, among other things.
3. Complex dynamic forms whose options change depending on prior selections.
4. Complex wizards or workflows that must maintain state across multiple screens.
5. Sequential flows that must be completed in a specific order, such as a welcome screen after login, then showing a tutorial, then prompting for a permission, etc.
6. Interruptable async operations

XState has a polarizing api, choosing to represent machines as long JSON objects. It also can have a steep learning curve. On top of learning fsm concepts, you must also learn the xstate api, which includes concepts like "context", "transitions", "guards", "actions", and "services". There is nothing to prevent you from writing overly-nested, poorly organized state machines, so it is important to stay mindful of when a machine has too many responsibilities. And while XState does work with Typescript, it uses a [Typegen tool](https://xstate.js.org/docs/guides/typescript.html) to acheive this, which has drawbacks. It will require changes to your CI pipeline TS checks, in order to generate the type definitions before running the TS checks. It also requires that you run the typegen tool every time you make a change to your machine definition. There is cli and VSCode tooling for this, but it is additional setup.

Testing XState machines is straightforward. It provides ways to mock out services, actions, or guards. It also supports [model-based testing](https://xstate.js.org/docs/packages/xstate-test/) to test a machine in every possible state. It's important to stay mindful you aren't testing the implementation details of a state machine by simply asserting about the machine's state, this seems to be a common trap people fall into.

XState might not be a good fit for one-off areas of complexity. It is a costly tradeoff in terms of new developer onboarding. Reaching for a simpler solution, such as React's own `useReducer` may suffice in these situations. If the state of something is simple enough, like most CRUD UIs tend to be, XState may be overkill. XState incurs a cost in boilerplate for setup with React components, so simple UIs don't stand to benefit at all, except if the UI is expected to become more complex in the near future.
